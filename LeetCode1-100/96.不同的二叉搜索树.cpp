/*
 * @lc app=leetcode.cn id=96 lang=cpp
 *
 * [96] 不同的二叉搜索树
 */

// @lc code=start
class Solution {
public:
//Catalan数分析
//通常通过出栈序列的个数来分析
//常规分析法：考察各个数字最后出栈的个数，设为k
//因为k 最后出栈，那么之前的1- k-1,已经出栈了，个数为 f(k - 1);
//之后的 k+1 - n，也要入栈接着出栈，个数为 f(n - k),所以，对于数字k,他最后出栈的个数为 f(k - 1) * f(n - k)
//综上，所有总数为k 取 1 - n的求和
//这里是按照数组k最后出栈来分析计算的，如果按照k最先出栈来分析呢，又该如何呢？
//今天分析了下，没有得到确切的公式，
//还有一种非常规分析：
//通过状态分析，入栈为1 ，出栈为0，考察所有可能的二进制组合方式，
//利用状态来分析问题，是很好的思路，
//就像寄存器中不是存储变量的值，而是存储变量的状态的变化
//【AC】
    int numTrees(int n) {
        int dp[n + 1] = {0};
        dp[0] = 1;
        dp[1] = 1;
        for(int i = 2;i <= n;++i)
        {
            for(int j = 1;j <= i;++j)
            {
                dp[i] += dp[j - 1] * dp[i - j];
            }
        }
        return dp[n];

    }
};
// @lc code=end

